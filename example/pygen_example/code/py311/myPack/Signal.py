""" This an autogenerated file using simosjs.generator
    Please do not edit
    Babak Ommani, Offshore Hydrodynamic, MARINTEK """

## signal in pi or opc
## Generated with Signal

#------------------------------------------------------------------------------
#modules
#importing general modules
from fnmatch import fnmatch
import numpy as np
import os
import warnings
import traceback
import collections
import uuid
import simos.storage as pyds
try:
    import json
except:
    print("WARNING: json is not installed.")
try:
    import h5py
except:
    print("WARNING: h5py is not installed.")
#importing extended types
#------------------------------------------------------------------------------
#@@@@@ USER DEFINED IMPORTS START @@@@@
#@@@@@ USER DEFINED IMPORTS End   @@@@@
#------------------------------------------------------------------------------

#******************************************************************************
class Signal(object):
    #---------------------------------------------------------------------------
    def __init__(self,name=None):
        self.MODEL = {"name":"Signal","description":"signal in pi or opc","extends":[],"properties":[{"name":"name","type":"string","description":"signal name","value":"signal","contained":True,"optional":False},{"name":"description","type":"string","description":"measurement description","value":"","contained":True,"optional":False},{"name":"type","type":"string","contained":True,"optional":False},{"name":"xdescription","type":"string","description":"descriptin of x axis","value":"","contained":True,"optional":False},{"name":"source_tag","type":"string","description":"source tag","value":"","contained":True,"optional":False},{"name":"variable_tag","type":"string","description":"variable tag","value":"","contained":True,"optional":False},{"name":"sample_tag","type":"string","description":"tag in pi","value":"","contained":True,"optional":False},{"name":"tag_pi","type":"string","description":"tag in pi","value":"","contained":True,"optional":False},{"name":"tag_opc","type":"string","description":"tag in opc on board","value":"","contained":True,"optional":False},{"name":"systemID","type":"string","description":"system id","value":"","contained":True,"optional":False},{"name":"unit","type":"string","description":"unit id","value":"","contained":True,"optional":False},{"name":"xunit","type":"string","description":"unit id","value":"","contained":True,"optional":False},{"name":"label","type":"string","description":"label","value":"","contained":True,"optional":False},{"name":"xlabel","type":"string","description":"x label","value":"","contained":True,"optional":False},{"name":"xname","type":"string","description":"x label","value":"","contained":True,"optional":False},{"name":"start_time","type":"myPack:Date","description":"time stamps","contained":True,"optional":False},{"name":"xvalue","type":"float","description":"time stamps in seconds from start","dim":"*","contained":True,"optional":False},{"name":"value","type":"float","description":"values","dim":"*","contained":True,"optional":False}],"type":"myPack:Signal","package":"myPack","__versions__":{"myPack":""}}
        self.ID = str(uuid.uuid4())
        self._saved = {}
        self.REF = None
        self._sync = {}
        self._STORAGE = None
        self._loadedItems = []
        self._name=str("signal")
        if not(name == None):
            self._name = name 
        self.MODELname = {"name":"name","type":"string","description":"signal name","value":"signal","contained":True,"optional":False}
        
        self._description= self._getInitValueDescription()
        self.MODELdescription = {"name":"description","type":"string","description":"measurement description","value":"","contained":True,"optional":False}
        
        self._type= self._getInitValueType()
        self.MODELtype = {"name":"type","type":"string","contained":True,"optional":False}
        
        self._xdescription= self._getInitValueXdescription()
        self.MODELxdescription = {"name":"xdescription","type":"string","description":"descriptin of x axis","value":"","contained":True,"optional":False}
        
        self._source_tag= self._getInitValueSource_tag()
        self.MODELsource_tag = {"name":"source_tag","type":"string","description":"source tag","value":"","contained":True,"optional":False}
        
        self._variable_tag= self._getInitValueVariable_tag()
        self.MODELvariable_tag = {"name":"variable_tag","type":"string","description":"variable tag","value":"","contained":True,"optional":False}
        
        self._sample_tag= self._getInitValueSample_tag()
        self.MODELsample_tag = {"name":"sample_tag","type":"string","description":"tag in pi","value":"","contained":True,"optional":False}
        
        self._tag_pi= self._getInitValueTag_pi()
        self.MODELtag_pi = {"name":"tag_pi","type":"string","description":"tag in pi","value":"","contained":True,"optional":False}
        
        self._tag_opc= self._getInitValueTag_opc()
        self.MODELtag_opc = {"name":"tag_opc","type":"string","description":"tag in opc on board","value":"","contained":True,"optional":False}
        
        self._systemID= self._getInitValueSystemID()
        self.MODELsystemID = {"name":"systemID","type":"string","description":"system id","value":"","contained":True,"optional":False}
        
        self._unit= self._getInitValueUnit()
        self.MODELunit = {"name":"unit","type":"string","description":"unit id","value":"","contained":True,"optional":False}
        
        self._xunit= self._getInitValueXunit()
        self.MODELxunit = {"name":"xunit","type":"string","description":"unit id","value":"","contained":True,"optional":False}
        
        self._label= self._getInitValueLabel()
        self.MODELlabel = {"name":"label","type":"string","description":"label","value":"","contained":True,"optional":False}
        
        self._xlabel= self._getInitValueXlabel()
        self.MODELxlabel = {"name":"xlabel","type":"string","description":"x label","value":"","contained":True,"optional":False}
        
        self._xname= self._getInitValueXname()
        self.MODELxname = {"name":"xname","type":"string","description":"x label","value":"","contained":True,"optional":False}
        
        self._start_time= self._getInitValueStart_time()
        self.MODELstart_time = {"name":"start_time","type":"myPack:Date","description":"time stamps","contained":True,"optional":False}
        
        self._xvalue= self._getInitValueXvalue()
        self.MODELxvalue = {"name":"xvalue","type":"float","description":"time stamps in seconds from start","dim":"*","contained":True,"optional":False}
        
        self._value= self._getInitValueValue()
        self.MODELvalue = {"name":"value","type":"float","description":"values","dim":"*","contained":True,"optional":False}
        
        self.OBJattrs = collections.OrderedDict()
        self._ungroupTypes = [""]
#------------------------------------------------------------------------------
#@@@@@ USER DEFINED PROPERTIES START @@@@@
#@@@@@ USER DEFINED PROPERTIES End   @@@@@
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#@@@@@ USER DEFINED METHODS START @@@@@
#@@@@@ USER DEFINED METHODS End   @@@@@
#------------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    #creating set and gets
    #----------------------------------------------------------------------
    @ property
    def name(self):
        return self._name
    #----------------------------------------------------------------------
    @ name.setter
    def name(self, val):
        self._name = str(val)
        if not("name" in self._loadedItems):
            self._loadedItems.append("name")
    #----------------------------------------------------------------------
    @ property
    def description(self):
        return self._description
    #----------------------------------------------------------------------
    @ description.setter
    def description(self, val):
        self._description = str(val)
        if not("description" in self._loadedItems):
            self._loadedItems.append("description")
    #----------------------------------------------------------------------
    @ property
    def type(self):
        return self._type
    #----------------------------------------------------------------------
    @ type.setter
    def type(self, val):
        self._type = str(val)
        if not("type" in self._loadedItems):
            self._loadedItems.append("type")
    #----------------------------------------------------------------------
    @ property
    def xdescription(self):
        return self._xdescription
    #----------------------------------------------------------------------
    @ xdescription.setter
    def xdescription(self, val):
        self._xdescription = str(val)
        if not("xdescription" in self._loadedItems):
            self._loadedItems.append("xdescription")
    #----------------------------------------------------------------------
    @ property
    def source_tag(self):
        return self._source_tag
    #----------------------------------------------------------------------
    @ source_tag.setter
    def source_tag(self, val):
        self._source_tag = str(val)
        if not("source_tag" in self._loadedItems):
            self._loadedItems.append("source_tag")
    #----------------------------------------------------------------------
    @ property
    def variable_tag(self):
        return self._variable_tag
    #----------------------------------------------------------------------
    @ variable_tag.setter
    def variable_tag(self, val):
        self._variable_tag = str(val)
        if not("variable_tag" in self._loadedItems):
            self._loadedItems.append("variable_tag")
    #----------------------------------------------------------------------
    @ property
    def sample_tag(self):
        return self._sample_tag
    #----------------------------------------------------------------------
    @ sample_tag.setter
    def sample_tag(self, val):
        self._sample_tag = str(val)
        if not("sample_tag" in self._loadedItems):
            self._loadedItems.append("sample_tag")
    #----------------------------------------------------------------------
    @ property
    def tag_pi(self):
        return self._tag_pi
    #----------------------------------------------------------------------
    @ tag_pi.setter
    def tag_pi(self, val):
        self._tag_pi = str(val)
        if not("tag_pi" in self._loadedItems):
            self._loadedItems.append("tag_pi")
    #----------------------------------------------------------------------
    @ property
    def tag_opc(self):
        return self._tag_opc
    #----------------------------------------------------------------------
    @ tag_opc.setter
    def tag_opc(self, val):
        self._tag_opc = str(val)
        if not("tag_opc" in self._loadedItems):
            self._loadedItems.append("tag_opc")
    #----------------------------------------------------------------------
    @ property
    def systemID(self):
        return self._systemID
    #----------------------------------------------------------------------
    @ systemID.setter
    def systemID(self, val):
        self._systemID = str(val)
        if not("systemID" in self._loadedItems):
            self._loadedItems.append("systemID")
    #----------------------------------------------------------------------
    @ property
    def unit(self):
        return self._unit
    #----------------------------------------------------------------------
    @ unit.setter
    def unit(self, val):
        self._unit = str(val)
        if not("unit" in self._loadedItems):
            self._loadedItems.append("unit")
    #----------------------------------------------------------------------
    @ property
    def xunit(self):
        return self._xunit
    #----------------------------------------------------------------------
    @ xunit.setter
    def xunit(self, val):
        self._xunit = str(val)
        if not("xunit" in self._loadedItems):
            self._loadedItems.append("xunit")
    #----------------------------------------------------------------------
    @ property
    def label(self):
        return self._label
    #----------------------------------------------------------------------
    @ label.setter
    def label(self, val):
        self._label = str(val)
        if not("label" in self._loadedItems):
            self._loadedItems.append("label")
    #----------------------------------------------------------------------
    @ property
    def xlabel(self):
        return self._xlabel
    #----------------------------------------------------------------------
    @ xlabel.setter
    def xlabel(self, val):
        self._xlabel = str(val)
        if not("xlabel" in self._loadedItems):
            self._loadedItems.append("xlabel")
    #----------------------------------------------------------------------
    @ property
    def xname(self):
        return self._xname
    #----------------------------------------------------------------------
    @ xname.setter
    def xname(self, val):
        self._xname = str(val)
        if not("xname" in self._loadedItems):
            self._loadedItems.append("xname")
    #----------------------------------------------------------------------
    @ property
    def start_time(self):
        name = "start_time"
        if  not(self.STORAGE ==None) and not(name in self._loadedItems) and (self._start_time == None):
            self._loadDataItem(name)
        return self._start_time
    #----------------------------------------------------------------------
    @ start_time.setter
    def start_time(self, val):
        if not(isinstance(val, myPack.Date.Date)):
            warnings.warn("variable type for start_time must be an instance of myPack:Date while " + str(type(val)) + " is passed. Make sure they are compatible.", RuntimeWarning)
        self._start_time = val
        if not("start_time" in self._loadedItems):
            self._loadedItems.append("start_time")
    #----------------------------------------------------------------------
    @ property
    def xvalue(self):
        name = "xvalue"
        if  not(self.STORAGE ==None) and not(name in self._loadedItems) :
            self._loadDataItem(name)
        return self._xvalue
    #----------------------------------------------------------------------
    @ xvalue.setter
    def xvalue(self, val):
        self._xvalue = np.array(val)
        if not("xvalue" in self._loadedItems):
            self._loadedItems.append("xvalue")
    #----------------------------------------------------------------------
    @ property
    def value(self):
        name = "value"
        if  not(self.STORAGE ==None) and not(name in self._loadedItems) :
            self._loadDataItem(name)
        return self._value
    #----------------------------------------------------------------------
    @ value.setter
    def value(self, val):
        self._value = np.array(val)
        if not("value" in self._loadedItems):
            self._loadedItems.append("value")

    @ property
    def STORAGE(self):
        return self._STORAGE
    
    @ STORAGE.setter
    def STORAGE(self,val):
        if (val.backEnd == 'hdf5') or (val.backEnd == 'mongodb'):
            self._STORAGE = val
        else:
            raise Exception("storage back-end " + val.backEnd + " is not defined.")

    #creating array functions for updating sizes


    #---------------------------------------------------------------------------
    def sweep(self, item, cmd=None):
        l = []
        if (isinstance(item,(list,np.ndarray))):
            for i in item:
                l += [sweep(i, cmd)]
        else:
            if (cmd == None):
                l = item
            else:
                l = eval(cmd)
        return l
    #---------------------------------------------------------------------------
    def isString(self, txt):
        if (type(txt) == type("")) or (type(txt) == np.string_) or isinstance(txt, str):
            return True
        else :
            return False
    #---------------------------------------------------------------------------
    def isStringArray(self, arr):
        shape = self.getShape(arr)
        item = arr
        if (len(shape) > 0):
            for d in shape:
                item = item[0]
        return self.isString(item)
    #---------------------------------------------------------------------------
    def getShape(self, arr):
        shape = []
        if (isinstance(arr,(list,np.ndarray))):
            if (len(arr) == 0):
                return shape
            shape += [len(arr)]
            shape += self.getShape(arr[0])
            return shape
        else :
            return shape
    #---------------------------------------------------------------------------
    def __repr__(self):
        return ( json.dumps(self.dictRepr(short=True, deep=False), indent=4, separators=(',', ': ')) )
        
    #---------------------------------------------------------------------------
    def typeRepr(self):
        rep = collections.OrderedDict()
        rep["__type__"] = "myPack:Signal"
        rep["__ID__"] = self.ID
        rep["name"] = self.name
        rep["description"] = self.description
        return rep
    #---------------------------------------------------------------------------
    def dictRepr(self, allItems=False, short=False, deep = True):
        rep = collections.OrderedDict()
        rep["__type__"] = "myPack:Signal"
        if not(short):
            rep["__versions__"] = {"myPack":""}
        rep["__ID__"] = self.ID
        rep["name"] = self.name
        rep["description"] = self.description
        if (allItems or self.isSet("name")):
            rep["name"] = self.name
        if (allItems or self.isSet("description")):
            rep["description"] = self.description
        if (allItems or self.isSet("type")):
            rep["type"] = self.type
        if (allItems or self.isSet("xdescription")):
            rep["xdescription"] = self.xdescription
        if (allItems or self.isSet("source_tag")):
            rep["source_tag"] = self.source_tag
        if (allItems or self.isSet("variable_tag")):
            rep["variable_tag"] = self.variable_tag
        if (allItems or self.isSet("sample_tag")):
            rep["sample_tag"] = self.sample_tag
        if (allItems or self.isSet("tag_pi")):
            rep["tag_pi"] = self.tag_pi
        if (allItems or self.isSet("tag_opc")):
            rep["tag_opc"] = self.tag_opc
        if (allItems or self.isSet("systemID")):
            rep["systemID"] = self.systemID
        if (allItems or self.isSet("unit")):
            rep["unit"] = self.unit
        if (allItems or self.isSet("xunit")):
            rep["xunit"] = self.xunit
        if (allItems or self.isSet("label")):
            rep["label"] = self.label
        if (allItems or self.isSet("xlabel")):
            rep["xlabel"] = self.xlabel
        if (allItems or self.isSet("xname")):
            rep["xname"] = self.xname
        if (allItems or self.isSet("start_time")):
            if (short and not(deep)):
                rep["start_time"] = (self.start_time.typeRepr())
            else:
                rep["start_time"] = self.start_time.dictRepr(allItems, short, deep)
        if (allItems or self.isSet("xvalue")):
            if (short):
                rep["xvalue"] = str(self.xvalue.shape)
            else:
                rep["xvalue"] = self.xvalue.tolist()
        if (allItems or self.isSet("value")):
            if (short):
                rep["value"] = str(self.value.shape)
            else:
                rep["value"] = self.value.tolist()
        return rep
    #---------------------------------------------------------------------------
    def dictDMTRepr(self, allItems=False, short=False, deep = True, bpDataSource=None):
        rep = collections.OrderedDict()
        rep["type"] = "/" + "myPack/Signal"
        if not(bpDataSource == None):
            rep["type"] = bpDataSource + "/" + rep["type"]
        rep["name"] = self.name
        rep["description"] = self.description
        if (allItems or self.isSet("name")):
            rep["name"] = self.name
        if (allItems or self.isSet("description")):
            rep["description"] = self.description
        if (allItems or self.isSet("type")):
            rep["type"] = self.type
        if (allItems or self.isSet("xdescription")):
            rep["xdescription"] = self.xdescription
        if (allItems or self.isSet("source_tag")):
            rep["source_tag"] = self.source_tag
        if (allItems or self.isSet("variable_tag")):
            rep["variable_tag"] = self.variable_tag
        if (allItems or self.isSet("sample_tag")):
            rep["sample_tag"] = self.sample_tag
        if (allItems or self.isSet("tag_pi")):
            rep["tag_pi"] = self.tag_pi
        if (allItems or self.isSet("tag_opc")):
            rep["tag_opc"] = self.tag_opc
        if (allItems or self.isSet("systemID")):
            rep["systemID"] = self.systemID
        if (allItems or self.isSet("unit")):
            rep["unit"] = self.unit
        if (allItems or self.isSet("xunit")):
            rep["xunit"] = self.xunit
        if (allItems or self.isSet("label")):
            rep["label"] = self.label
        if (allItems or self.isSet("xlabel")):
            rep["xlabel"] = self.xlabel
        if (allItems or self.isSet("xname")):
            rep["xname"] = self.xname
        if (allItems or self.isSet("start_time")):
            if (short and not(deep)):
                rep["start_time"] = (self.start_time.typeRepr())
            else:
                rep["start_time"] = self.start_time.dictDMTRepr(allItems=allItems, short=short, deep=deep, bpDataSource=bpDataSource)
        if (allItems or self.isSet("xvalue")):
            if (short):
                rep["xvalue"] = str(self.xvalue.shape)
            else:
                rep["xvalue"] = self.xvalue.tolist()
        if (allItems or self.isSet("value")):
            if (short):
                rep["value"] = str(self.value.shape)
            else:
                rep["value"] = self.value.tolist()
        return rep
    #---------------------------------------------------------------------------
    def jsonRepr(self, short=False, deep=True):
        return ( json.dumps(self.dictRepr(short=short, deep=deep),indent=4, separators=(',', ': ')) )
        
    #---------------------------------------------------------------------------
    def dmtRepr(self, short=False, deep=True, bpDataSource=None):
        return ( json.dumps(self.dictDMTRepr(short=short, deep=deep, bpDataSource=bpDataSource),indent=4, separators=(',', ': ')) )
        
    #---------------------------------------------------------------------------
    def clone(self):
        newObj = Signal()
        return self._cloneTo(newObj)
        
    def cloneTo(self, newObj):
        self._cloneTo(newObj)
        
    def _cloneTo(self,newObj):
        if (self.isSet("name")):
            newObj._name = self._name
        if (self.isSet("description")):
            newObj._description = self._description
        if (self.isSet("type")):
            newObj._type = self._type
        if (self.isSet("xdescription")):
            newObj._xdescription = self._xdescription
        if (self.isSet("source_tag")):
            newObj._source_tag = self._source_tag
        if (self.isSet("variable_tag")):
            newObj._variable_tag = self._variable_tag
        if (self.isSet("sample_tag")):
            newObj._sample_tag = self._sample_tag
        if (self.isSet("tag_pi")):
            newObj._tag_pi = self._tag_pi
        if (self.isSet("tag_opc")):
            newObj._tag_opc = self._tag_opc
        if (self.isSet("systemID")):
            newObj._systemID = self._systemID
        if (self.isSet("unit")):
            newObj._unit = self._unit
        if (self.isSet("xunit")):
            newObj._xunit = self._xunit
        if (self.isSet("label")):
            newObj._label = self._label
        if (self.isSet("xlabel")):
            newObj._xlabel = self._xlabel
        if (self.isSet("xname")):
            newObj._xname = self._xname
        if (self.isSet("start_time")):
            newObj._start_time = self._start_time.clone()
        if (self.isSet("xvalue")):
            newObj._xvalue = np.copy(self._xvalue)
        if (self.isSet("value")):
            newObj._value = np.copy(self._value)
        return newObj
    #---------------------------------------------------------------------------
    #---------------------Entity access functions ------------------------------
    #---------------------------------------------------------------------------
    def hasEntity(self,name):
        objs = self._lookForEntity(name)
        if (len(objs) == 1):
            return True
        else:
            return False
    #---------------------------------------------------------------------------
    def getEntity(self,name):
        objs = self._lookForEntity(name)
        if (len(objs) == 1):
            return objs[0]
        else:
            raise Exception("did not find Entity: %s"%name)
    #---------------------------------------------------------------------------
    def _lookForEntity(self,name):
        objs = []
        if (self.start_time != None): 
            if (self.start_time.name == name ):
                objs.append(self.start_time)
        if (len(objs) > 1):
            raise Exception("more than one Entity found with the name: %s"%name)
        return objs
    #---------------------------------------------------------------------------
    def getEntityWith(self,propName, propValue):
        objs = self._lookForEntityWith(propName, propValue)
        if (len(objs) == 0):
            raise Exception( ("No Entity found with the property %s and value "%propName) + str(propValue) )
        if (len(objs) > 1):
            raise Exception( ("more than one Entity found the property %s and value "%propName) + str(propValue) )
        return objs[0]
    #---------------------------------------------------------------------------
    def getAllEntitiesWith(self,propName, propValue):
        objs = self._lookForEntityWith(propName, propValue)
        return objs
    #---------------------------------------------------------------------------
    def hasEntityWith(self,propName, propValue):
        objs = self._lookForEntityWith(propName, propValue)
        if (len(objs) == 0):
            return False
        return True
    #---------------------------------------------------------------------------
    def _lookForEntityWith(self,propName, propValue):
        objs = []
        return objs
    #---------------------------------------------------------------------------
    def find(self,name=None, path=None, namePath = "", accPath="", propType=None):
        objs = []
        accPaths = []
        namePaths = []
        return objs, accPaths
    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    #---------------------check functions --------------------------------------
    #---------------------------------------------------------------------------
    def isSet(self, varName):
        if (isinstance(getattr(self,varName),list) ):
            if (len(getattr(self,varName)) > 0 and not any([np.any(a==None) for a in getattr(self,varName)])  ):
                return True
            else :
                return False
        if (isinstance(getattr(self,varName),np.ndarray) ):
            if (len(getattr(self,varName)) > 0 and not any([np.any(a==None) for a in getattr(self,varName)])  ):
                return True
            else :
                return False
        if (getattr(self,varName) != None):
            return True
        return False
    #---------------------------------------------------------------------------
    def isContained(self, varName):
        MODEL = self.getPropModel(varName)
        if ("containment" in list(MODEL.keys()) ):
            if (MODEL["containment"] == "false"):
                return False
        return True
    #---------------------------------------------------------------------------
    def getPropModel(self, varName):
        props = self.MODEL["properties"]
        for prop in props:
            if (prop["name"] == varName):
                return prop
        raise Exception("property " + varName + " was not found.")
    #---------------------------------------------------------------------------
    def _getInitValueName(self):
        val =str("signal")
        return val
    
    def _getInitValueDescription(self):
        val =str("")
        return val
    
    def _getInitValueType(self):
        val = None
        return val
    
    def _getInitValueXdescription(self):
        val =str("")
        return val
    
    def _getInitValueSource_tag(self):
        val =str("")
        return val
    
    def _getInitValueVariable_tag(self):
        val =str("")
        return val
    
    def _getInitValueSample_tag(self):
        val =str("")
        return val
    
    def _getInitValueTag_pi(self):
        val =str("")
        return val
    
    def _getInitValueTag_opc(self):
        val =str("")
        return val
    
    def _getInitValueSystemID(self):
        val =str("")
        return val
    
    def _getInitValueUnit(self):
        val =str("")
        return val
    
    def _getInitValueXunit(self):
        val =str("")
        return val
    
    def _getInitValueLabel(self):
        val =str("")
        return val
    
    def _getInitValueXlabel(self):
        val =str("")
        return val
    
    def _getInitValueXname(self):
        val =str("")
        return val
    
    def _getInitValueStart_time(self):
        val =myPack.Date.Date("start_time")
        val.name = "start_time"
        val.description = "time stamps"
        return val
    
    def _getInitValueXvalue(self):
        val = np.empty(shape=(1), dtype=float)
        val.fill(0.0)
        return val
    
    def _getInitValueValue(self):
        val = np.empty(shape=(1), dtype=float)
        val.fill(0.0)
        return val
    
    #---------------------------------------------------------------------------
    def create(self,name=None):
        if (name != None) and not(self.isString(name)):
            raise Exception("name should be string %s is given."%(type(name)))
        return Signal(name)
    def makeaStart_time(self,name=None):
        if (name != None) and not(self.isString(name)):
            raise Exception("name should be string %s is given."%(type(name)))
        return myPack.Date.Date(name)
    def createStart_time(self, name=None):
        if (name != None) and not(self.isString(name)):
            raise Exception("name should be string %s is given."%(type(name)))
        if (self.start_time != None): 
            raise Exception("object start_time already exist, use renewStart_time to get a new one.") 
        return self.renewStart_time(name)
    def deleteStart_time(self):
        self._start_time = None 
    def renewStart_time(self, name=None):
        if (name != None) and not(self.isString(name)):
            raise Exception("name should be string %s is given."%(type(name)))
        self.start_time = myPack.Date.Date("start_time")
        self.start_time.name = "start_time"
        self.start_time.description = "time stamps"
        if name != None:
            self.start_time.name = name
        return self.start_time
    
    #---------------------------------------------------------------------------
    def save(self,filePath=None, dsType = 'hdf5'):
        self.saveHDF5(filePath=filePath, dsType=dsType)
    #---------------------------------------------------------------------------
    def load(self,name=None, filePath=None, dsType = 'hdf5', action="init", hdfPath=None):
        self.loadHDF5(name, filePath=filePath, dsType=dsType, action=action, hdfPath=hdfPath)
    def _loadInit(self):
            self._loadedItems = []
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
            self._start_time = None
        
            self._xvalue = np.array([])
        
            self._value = np.array([])
        
        
    #---------------------------------------------------------------------------
    def _loadDataItem(self,name):
        if self.STORAGE.backEnd == 'hdf5':
            self._loadDataItemFromHDF5(name)
        elif self.STORAGE.backEnd == 'mongodb':
            self._loadDataItemFromMongo(name)
        else:
            raise Exception("storage back-end " + self.STORAGE.backEnd + " is not defined.")
    #---------------------------------------------------------------------------
    def loadJSON(self,name = None, filePath = None):
        if not(name == None):
            self.name = name
        if (name == None) and not(filePath == None):
            self.name = '.'.join(filePath.split(os.path.sep)[-1].split('.')[0:-1])
        if (filePath == None):
            if hasattr(self, 'name'):
                filePath = self.name + '.json'
            else:
                raise Exception("object needs name for loading.")
    
        if not(os.path.isfile(filePath)):
            raise Exception("file %s not found."%filePath)
    
        self._loadedItems = []
    
        f = open(filePath,'r')
        data = f.read()
        f.close()
        dd = json.loads(data)
        self.loadFromJSONDict(dd)
    
    def loadFromJSONDict(self, data):
        self.ID = str(data["__ID__"])
        varName = "name"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "description"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "type"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xdescription"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "source_tag"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "variable_tag"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "sample_tag"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "tag_pi"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "tag_opc"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "systemID"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "unit"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xunit"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "label"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xlabel"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xname"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "start_time"
        try :
            createFunc = getattr(self,"create" + varName[0].capitalize()+varName[1:] )
            item = createFunc()
            item.loadFromJSONDict(data[varName])
        except :
            pass
        
        varName = "xvalue"
        try :
            setattr(self,varName, np.array(data[varName]))
        except :
            pass
        
        varName = "value"
        try :
            setattr(self,varName, np.array(data[varName]))
        except :
            pass
        
        pass
        
    #---------------------------------------------------------------------------
    def saveJSON(self, fileName=None):
        if fileName==None:
            fileName=self.name + ".json"
        f = open(fileName, "w")
        f.write(self.jsonRepr())
        f.close()
        pass
        
    #---------------------------------------------------------------------------
    def saveDMT(self, fileName=None, bpDataSource=None):
        if fileName==None:
            fileName=self.name + ".json"
        f = open(fileName, "w")
        f.write(self.dmtRepr(bpDataSource=bpDataSource))
        f.close()
        pass
        
    def loadFromDMTDict(self, data):
        varName = "name"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "description"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "type"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xdescription"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "source_tag"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "variable_tag"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "sample_tag"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "tag_pi"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "tag_opc"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "systemID"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "unit"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xunit"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "label"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xlabel"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "xname"
        try :
            setattr(self,varName, data[varName])
        except :
            pass 
        
        varName = "start_time"
        try :
            createFunc = getattr(self,"create" + varName[0].capitalize()+varName[1:] )
            item = createFunc()
            item.loadFromDMTDict(data[varName])
        except :
            pass
        
        varName = "xvalue"
        try :
            setattr(self,varName, np.array(data[varName]))
        except :
            pass
        
        varName = "value"
        try :
            setattr(self,varName, np.array(data[varName]))
        except :
            pass
        
        pass
        
    def loadDMT(self,name = None, filePath = None):
        if not(name == None):
            self.name = name
        if (name == None) and not(filePath == None):
            self.name = '.'.join(filePath.split(os.path.sep)[-1].split('.')[0:-1])
        if (filePath == None):
            if hasattr(self, 'name'):
                filePath = self.name + '.json'
            else:
                raise Exception("object needs name for loading.")
    
        if not(os.path.isfile(filePath)):
            raise Exception("file %s not found."%filePath)
    
        self._loadedItems = []
    
        f = open(filePath,'r')
        data = f.read()
        f.close()
        dd = json.loads(data)
        self.loadFromDMTDict(dd)
    
    #---------------------------------------------------------------------------
    #---------------------Load HDF5 functions ----------------------------------
    #---------------------------------------------------------------------------
    def loadHDF5(self,name=None, filePath=None, dsType = 'hdf5', action="init", hdfPath=None):
        if not(name == None):
            self.name = name
        if (filePath == None):
            if hasattr(self, 'name'):
                filePath = self.name + '.h5'
            else:
                raise Exception("object needs name for loading.")
    
        if not(os.path.isfile(filePath)):
            raise Exception("file %s not found."%filePath)
        if (name == None and hdfPath==None):
            #get first item name in the file as the object name
            tempFile = h5py.File(filePath, "r")
            folders = list(tempFile.keys())
            if (len(folders) == 0):
                raise Exception("no object group in the file.")
            if (len(folders) > 1):
                warnings.warn("several objects exist in the file, %s . Loading of first object is tried. Please provide name in the input for others."%folders, RuntimeWarning)
            self.name = folders[0]
            tempFile.close()
    
        self.STORAGE = pyds.getDataStorageBackEndServer(dsType)
        self.STORAGE.filePath = filePath
    
        if hdfPath == None:
            self.STORAGE.path = self.STORAGE.path + self.name
        else:
            self.STORAGE.path = hdfPath
    
        if self.STORAGE.backEnd == 'hdf5':
            self.loadFromHDF5Handle(action = action)
        else:
            raise Exception("storage back-end " + self.STORAGE.backEnd + " is not defined.")
    
    def loadFromStorage(self, storage=None, dsType = 'hdf5', action="init"):
        if (dsType == 'hdf5') :
            self.loadFromHDF5Handle(storage=storage, action=action)
    def loadFromHDF5Handle(self, storage=None, action="init"):
        if (action == "init") or (action == "sync"):
            self._loadInit()
        if storage != None:
            self.STORAGE = storage
    
        if self.STORAGE.isConnected() and not(self.STORAGE.isOpen()):
            self.STORAGE.openRead()
            self._loadDataFromHDF5Handle(action=action)
        if self.STORAGE.isOpen():
            self.STORAGE.close()
    def _loadDataItemFromHDF5(self, itemName):
        if self.STORAGE.isConnected() and not(self.STORAGE.isOpen()):
            self.STORAGE.openRead()
        if (itemName == "name"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "name", "AtomicSingle", action="detach")
        if (itemName == "description"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "description", "AtomicSingle", action="detach")
        if (itemName == "type"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "type", "AtomicSingle", action="detach")
        if (itemName == "xdescription"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "xdescription", "AtomicSingle", action="detach")
        if (itemName == "source_tag"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "source_tag", "AtomicSingle", action="detach")
        if (itemName == "variable_tag"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "variable_tag", "AtomicSingle", action="detach")
        if (itemName == "sample_tag"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "sample_tag", "AtomicSingle", action="detach")
        if (itemName == "tag_pi"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "tag_pi", "AtomicSingle", action="detach")
        if (itemName == "tag_opc"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "tag_opc", "AtomicSingle", action="detach")
        if (itemName == "systemID"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "systemID", "AtomicSingle", action="detach")
        if (itemName == "unit"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "unit", "AtomicSingle", action="detach")
        if (itemName == "xunit"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "xunit", "AtomicSingle", action="detach")
        if (itemName == "label"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "label", "AtomicSingle", action="detach")
        if (itemName == "xlabel"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "xlabel", "AtomicSingle", action="detach")
        if (itemName == "xname"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "xname", "AtomicSingle", action="detach")
        if (itemName == "start_time"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "start_time", "NonAtomicSingle")
        if (itemName == "xvalue"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "xvalue", "AtomicArray", action="detach")
        if (itemName == "value"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "value", "AtomicArray", action="detach")
        
        if self.STORAGE.isOpen():
            self.STORAGE.close()
    def _loadDataFromHDF5Handle(self, action="init"):
        if self.STORAGE.isConnected() and not(self.STORAGE.isOpen()):
            self.STORAGE.openRead()
        handle = self.STORAGE.data
        if "ID" in list(handle.attrs.keys()):
            self.ID = str(handle.attrs["ID"])
        else:
            self.ID = str(uuid.uuid4())
        self.OBJattrs = collections.OrderedDict()
        try:
            for key,val in handle.attrs.items():
                self.OBJattrs[key] = val
        except:
            pass
        pyds.hdf5.loadFromHDF5HandleItem(self, "name", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "description", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "type", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "xdescription", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "source_tag", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "variable_tag", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "sample_tag", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "tag_pi", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "tag_opc", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "systemID", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "unit", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "xunit", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "label", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "xlabel", "AtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "xname", "AtomicSingle", action=action)
        if not(action == "init"):
            pyds.hdf5.loadFromHDF5HandleItem(self, "start_time", "NonAtomicSingle", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "xvalue", "AtomicArray", action=action)
        pyds.hdf5.loadFromHDF5HandleItem(self, "value", "AtomicArray", action=action)
        
        try:
            for key,val in handle.items():
                if isinstance(val, h5py.Dataset):
                    if not(key in ["name","description","type","xdescription","source_tag","variable_tag","sample_tag","tag_pi","tag_opc","systemID","unit","xunit","label","xlabel","xname","xvalue","value"]):
                        self.OBJattrs[key] = val.value
        except:
            pass
        
        if self.STORAGE.isOpen():
            self.STORAGE.close()
        pass
    #---------------------------------------------------------------------------
    #---------------------Save HDF5 functions ----------------------------------
    #---------------------------------------------------------------------------
    def saveHDF5(self,filePath=None, dsType = 'hdf5'):
        if (filePath == None):
            if hasattr(self, 'name'):
                filePath = self.name + '.h5'
            else:
                raise Exception("object needs name for saving.")
    
        print("	Saving %s to %s ..."%(self.name, filePath))
    
        if (self.STORAGE):
            if (self.STORAGE.backEnd == 'hdf5'):
                self.loadFromHDF5Handle(action="detach")
        storage = pyds.getDataStorageBackEndServer(dsType)
        storage.filePath = filePath
        storage.openWrite()
    
        grpHandle = storage.handle
        self._saveVertionsToHDF5Handle(grpHandle)
        dgrp = grpHandle.create_group(self.name)
    
        storage.appendPath(self.name)
    
        self._saved = {}
        if storage.backEnd == 'hdf5':
            self.saveToHDF5Handle(dgrp)
        else:
            raise Exception("storage back-end " + self._storageBackEndType + " is not defined.")
    
        if storage.isOpen():
            storage.close()
        return storage
    def _saveVertionsToHDF5Handle(self, handle):
        handle.attrs["myPack"] = ""
        pass
    def saveToHDF5Handle(self, handle):
        #first pass to save all contained items
        self._saveDataToHDF5Handle(handle)
        pass
        
    def _saveDataToHDF5Handle(self, handle):
        self.REF = handle.ref
        handle.attrs["type"] = "myPack:Signal"
        handle.attrs["ID"] = self.ID
        if ("order" in list(handle.attrs.keys())):
            handle.attrs["order"] = []
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "name", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "description", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "type", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "xdescription", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "source_tag", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "variable_tag", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "sample_tag", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "tag_pi", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "tag_opc", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "systemID", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "unit", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "xunit", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "label", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "xlabel", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "xname", "AtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "start_time", "NonAtomicSingle")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "xvalue", "AtomicArray")
        
        pyds.hdf5.saveToHDF5HandleItem(self, handle, "value", "AtomicArray")
        
        order = []
        if (self.isSet("name")):
            order.append("name")
        if (self.isSet("description")):
            order.append("description")
        if (self.isSet("type")):
            order.append("type")
        if (self.isSet("xdescription")):
            order.append("xdescription")
        if (self.isSet("source_tag")):
            order.append("source_tag")
        if (self.isSet("variable_tag")):
            order.append("variable_tag")
        if (self.isSet("sample_tag")):
            order.append("sample_tag")
        if (self.isSet("tag_pi")):
            order.append("tag_pi")
        if (self.isSet("tag_opc")):
            order.append("tag_opc")
        if (self.isSet("systemID")):
            order.append("systemID")
        if (self.isSet("unit")):
            order.append("unit")
        if (self.isSet("xunit")):
            order.append("xunit")
        if (self.isSet("label")):
            order.append("label")
        if (self.isSet("xlabel")):
            order.append("xlabel")
        if (self.isSet("xname")):
            order.append("xname")
        if (self.isSet("start_time")):
            order.append("start_time")
        if (self.isSet("xvalue")):
            order.append("xvalue")
        if (self.isSet("value")):
            order.append("value")
        if ("order" in list(handle.attrs.keys())):
            curOrders = [a.decode("ascii") for a in handle.attrs["order"]]
            if ( len(list(curOrders)) > 0 ):
                order = list(curOrders) + order
        handle.attrs["order"] = [a.encode("ascii") for a in order]
        for key,val in self.OBJattrs.items():
            #type is exception and it will be overwriten
            if (key == "type"):
                handle.attrs[key] = val
            #skip name and description
            if (key == "name" or key == "description"):
                continue
            if (not key in list(handle.attrs.keys())):
                handle.attrs[key] = val
#---------------------------------------------------------------------------
#modules
#importing referenced types
import myPack.Date

#******************************************************************************